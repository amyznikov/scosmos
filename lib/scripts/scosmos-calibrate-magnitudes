#! /usr/bin/octave -qf

format short;
ignore_function_time_stamp("all");
if ( exist(__sub=sprintf("%s/octave",pwd()),'dir' ) )
  addpath(__sub);
endif

arg_list = argv ();


#######################################################################

function show_usage( stream )
  fprintf (stream, "Usage:\n");
  fprintf (stream, "  %s {stage1|stage2|stage3|stage4} [OPTIONS] [ARGS]\n", program_name ());
  fprintf (stream, "stage1 arguments:\n");
  fprintf (stream, "  -o <calibration-output-file-name> plateid ...\n");
  fprintf (stream, "stage2 arguments:\n");
  fprintf (stream, "  calibration-file-name\n");
  fprintf (stream, "stage3 arguments:\n");
  fprintf (stream, "  -c {SERCJ|SERCR|SERCI|ESOR} sdss2psc.dat ... \n");
  fprintf (stream, "stage4 arguments:\n");
  fprintf (stream, "  -c {SERCJ|SERCR|SERCI|ESOR} -o mc.calib plateid ... \n");
end


#######################################################################
# Linear map 2MASS JHK into some magnitude system defined by vector C
function m = psc2mag( C, J, H, K )
  m = C(1) + C(2) * J + C(3) * H + C(4) * K;
end


#######################################################################
# inner join for scosmos and psc

function [status, A0, D0] = mkspsc(plateid, sname, pscname, spscname, noprep, ej, eh, ek, jmin, jmax, hmin, hmax, kmin, kmax, cosmagmin, cosmagmax )

  status = 0;

  R = 2.5;

  # get scosmos data
  fprintf(stderr,"get scosmos data\n");
  cmd = get_plate_pipe_command( plateid, "-hcf" );
  if ( !strcmp(cmd,"") )
    syscall("%s | ccut -f ra,dec,isky,cosmag -c 'cosmag>%g && cosmag<%g && class==2' > %s", cmd, cosmagmin, cosmagmax, sname );
  else
    fprintf(stderr,"ERROR: can not find scosmos plate location for plateid=%d\n",plateid);
    return;
  end

  # get psc data
  if ( noprep )
    A0 = 0;
    D0 = 0;
  else
    printf("get psc data\n");

    v = sscanf(pgquery("select distinct rapnt, decpnt from ssa_plates where plateid=%d", plateid),"%lf");
    if ( size(v,1) != 2 )
      error("can not get field center for plateid=%d\n",plateid);
    end

    A0 = v(1);
    D0 = v(2);
    printf("A0:  %g\n",A0);
    printf("D0: %+g\n",D0);

    syscall("psql wsdb -c  \
      \\\"copy( select ra, dec,j_m, h_m, k_m from psc  \
          where spoint(ra,dec) @ scircle(spoint(%.9f*pi()/180,%+.9f*pi()/180),6*pi()/180)     \
           and (j_m < 10 or (j_msigcom < %g and h_msigcom < %g and k_msigcom < %g))           \
           and j_m between %g and %g                                        \
           and h_m between %g and %g                                        \
           and k_m between %g and %g                                        \
           and j_m - k_m between 0.1 and 0.8                                \
        ) to stdout with csv header delimiter E'\\t'\\\" > %s",
         A0, D0, ej, eh, ek, jmin, jmax, hmin, hmax, kmin, kmax, pscname );
  end

  # join plates
  printf("join plates\n");
  syscall("ssa-pair-stars rc1=1 dc1=2 rc2=1 dc2=2 r=%g dups=drop -v %s %s -o %s", R, sname, pscname, spscname );
  status = 1;
end


#######################################################################
#
# Rough linear estimator for JHK -> cosmag
#

function calibrate_stage1( plateid, outputname, noprep )

  # get process id to format temporary file names
  pid = getpid ();
  printf("pid=%d\n", pid);

  sname = sprintf("/tmp/scosmos.%d.%d.tmp", plateid, pid );
  spscname = sprintf("/tmp/scosmos.psc.%d.%d.tmp", plateid, pid);

  if ( noprep )
    pscname = "psc.dat";
  else
    pscname = sprintf("/tmp/psc.%d.%d.tmp", plateid, pid);
  end

  # check if this field is already processed
  if ( exist(outputname,"file") )
    s = system(sprintf("egrep -q '^\\s*%d\t' %s", plateid, outputname));
    if ( s == 0 )
      printf("\nSKIP %d BECAUSE ALREADY PROCESSES\n\n", plateid);
      return;
    end
  end

  [status, A0, D0 ] = mkspsc(plateid, sname, pscname, spscname, noprep,0.30,0.35,0.35,8.5,15.2,8,14.5,8,14.5,-26.5,-23.75);
  if ( !status )
    printf("\nSKIP %d BECAUSE mkspsc() FAILS\n\n", plateid);
    return;
  end


  # load reference stars
  printf("load reference stars\n");
  fid = popenq(spscname, "isky cosmag j_m h_m k_m" );
  if ( fid == -1 )
    error("ERROR: can not read %s\n", fname);
  end

  v = transpose(fscanf(fid, "%lf", [5, Inf]));
  pclose(fid);

  # remove temp files
  if ( noprep )
    syscall("rm -f %s %s", sname, spscname);
  else
    syscall("rm -f %s %s %s", sname, pscname, spscname);
  end

  # remove stars with poor sky background
  smin = min( v(:,1) ) + 1e6;
  smax = max( v(:,1) ) - 1e6;
  good = v(:,1) >= smin & v(:,1) <= smax;
  if ( ~all(good) )
    v = v (good,:);
  end

  # extract columns
  cosmag = v(:,2);
  j_m = v(:,3);
  h_m = v(:,4);
  k_m = v(:,5);
  MM = [ ones(size(cosmag)) j_m h_m k_m ];


  # solve linear model
  printf("solve model\n");

  NPASS = 5;
  K = 3;
  for pass = 1:NPASS

    [C, sigma,~,E] = LinearRegression(MM, cosmag);
    sigma = sqrt(sigma);

    printf("%d sigma=%g rows=%d\n", pass, sigma, rows(MM));

    ccosmag = MM * C;
    dcosmag = cosmag - ccosmag;

    if ( pass < NPASS )

      if( all(good = abs(dcosmag) < K * sigma) )
        break;
      end

      MM   = MM(good,:);
      cosmag = cosmag(good);
      j_m  = j_m(good);
      h_m  = h_m(good);
      k_m  = k_m(good);
    end

  endfor

  if ( exist(outputname,"file") )
    fid = fopen(outputname,"a");
  else
    fid = fopen(outputname,"w");
    fprintf(fid,"plateid\tA0\tD0\tC0\tC1\tC2\tC3\tsigma\tE0\tE1\tE2\tE3\n");
  endif

  E = sqrt(E);
  fprintf(fid,"%8d\t%9.3f\t%+9.3f\t%+15.9E\t%+15.9E\t%+15.9E\t%+15.9E\t%9.3f\t%9.3E\t%9.3E\t%9.3E\t%9.3E\n",
     plateid, A0, D0, C(1), C(2), C(3), C(4), sigma, E(1), E(2), E(3), E(4) );
  fclose(fid);


  dirname = "mc.stage1.res";
  syscall("mkdir -p %s", dirname);
  fname = sprintf("%s/%d.res", dirname, plateid);
  if ( (fid = fopen(fname,"w")) == -1 )
    fprintf(stderr,"ERROR: can not write %s\n", fname); return;
  end

  fprintf(fid,"j_m\th_m\tk_m\tcosmag\tccosmag\n");
  fprintf(fid,"%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n",
    transpose([j_m h_m k_m cosmag ccosmag]));
  fclose(fid);
  printf("%s saved\n", fname);

end



#######################################################################
# Select average of JHK->cosmag calibration for all survey plates,
# dropping too large residuals

function calibrate_stage2(calibname)

  fid = popenq(calibname,"A0 D0 C0 C1 C2 C3 sigma");
  if ( fid == -1 )
    error("Can not read %s", calibname);
  end

  v = fscanf(fid,"%lf", [7, Inf]);
  fclose( fid );

  if ( size(v,1) != 7 )
    error("Invalid data in %s", calibname);
  end

  if ( ~all(below_threshold = v(7,:) < 0.125) )
    v = v(:,below_threshold);
  end

  if ( size(v,2) < 3 )
    error("Not enough data in %s (%d)", calibname, cols(v));
  end

#  [L,B] = eq2gal(A0*pi/180,D0*pi/180);
%   A0    = v(1,:);
%   D0    = v(2,:);
  CC    = v(3:6,:);

  NPASS = 3;
  K = 3;
  for  pass = 1:NPASS

    for ( i=1:4 )
      C(i) = mean(CC(i,:));
      E(i) = std(CC(i,:));
      printf("* %d C%d=%+9.6E E%d=%+9.6E\n", pass, i-1, C(i), i-1, E(i) );
    end

    if ( pass < NPASS )
      if ( all(all(good = abs(CC(1,:)-C(1)) < K * E(1) & abs(CC(2,:)-C(2)) < K * E(2) & abs(CC(3,:)-C(3)) < K * E(3) & abs(CC(4,:)-C(4)) < K * E(4))) )
        break;
      end
      CC = CC(:,good);
    end
  end

  printf("FINAL SOLUTION:\n");
  printf("C = [%+9.6E %+9.6E %+9.6E %+9.6E]\n", C(1), C(2), C(3), C(4) );
  printf("E = [%+9.6E %+9.6E %+9.6E %+9.6E]\n", E(1), E(2), E(3), E(4) );
  printf("J2S(J,H,K) = %9.6E%+9.6E*J%+9.6E*H%+9.6E*K\n", C(1), C(2), C(3), C(4) );

end

#######################################################################
#
# stage3 - linear map of averaged cosmag into SDSS/B(g,r) using 'good' subset of SDSS and PSC stars
#
function C = psc2cosmag( color )
  switch ( color )
    case "SERCJ"
      C = [ -3.164985E+01 +2.232129E+00  -9.308214E-01  -8.206416E-01 ];
    otherwise
      error("No calibration data for %s. Use stage2 to generate and insert it into this code.", color);
  end
end


function calibrate_stage3( color, sdss2psc )

  % load sdss/psc pairs
  v = [];

  for i=1:size(sdss2psc,2)

    fname = sdss2psc{i};
    printf("%s\n", fname);
    fid = popen(sprintf("ccut -f j_m,h_m,k_m,g,r,u,i,z %s -c 'j_msigcom<0.1 && h_msigcom<0.1 && k_msigcom<0.1 && j_m<18 && h_m<16 && k_m<16 && u>0 && u<22 && g>14 && r>14 && g<20 && r<20 && i>0 && z>0  && (g-j_m)<1.7 && (j_m-k_m)>0.25 && (j_m-k_m)<0.70' ",fname),"r");
    if ( fid == -1 )
      error("popen() fails for %s",fname);
    end

    fgets(fid); # skip header
    v = [ v fscanf(fid,"%lf",[8, Inf]) ];
    pclose(fid);
  end

  printf("size(v): %d x %d\n",size(v,1),size(v,2));

  # make linear regression
  v = transpose(v);

  C = psc2cosmag( color );
  j = v(:,1);
  h = v(:,2);
  k = v(:,3);
  g = v(:,4);
  r = v(:,5);
  u = v(:,6);
  i = v(:,7);
  z = v(:,8);

  cosmag = psc2mag( C, j,  h,  k );
  if ( ~all( good = cosmag < -23.5) ) # cosmag > -27 &
    j = j(good);
    h = h(good);
    k = k(good);
    g = g(good);
    r = r(good);
    u = u(good);
    i = i(good);
    z = z(good);
    cosmag = cosmag(good);
  end

  sdssmag = Sgr2B( g, r );
  MM  = [ones(size(cosmag)) cosmag ];

  NPASS = 5;
  K = 3;
  for pass = 1:NPASS

    [CC, sigma] = LinearRegression(MM, sdssmag);
    sigma = sqrt(sigma);

    printf("%d sigma=%g rows=%d\n", pass, sigma, rows(MM));

    if ( pass < NPASS )
      if( all(good = abs(sdssmag - MM * CC) < K * sigma) )
        break;
      end
      MM = MM(good,:);
      cosmag = cosmag(good);
      sdssmag = sdssmag(good);
      j = j(good);
      h = h(good);
      k = k(good);
      g = g(good);
      r = r(good);
      u = u(good);
      i = i(good);
      z = z(good);
    end
  endfor

  CCC = [ (CC(1)+CC(2)*C(1))  (CC(2)*C(2))  (CC(2)*C(3))  (CC(2)*C(4)) ] ;

  printf("SOLUTION:\n");
  printf("CC  = [%+9.6E %+9.6E]\n", CC(1), CC(2) );
  printf("CCC = [%+9.6E %+9.6E %+9.6E %+9.6E]\n", CCC(1), CCC(2), CCC(3), CCC(4) );
  printf("J2B(J,H,K) = %9.6E%+9.6E*J%+9.6E*H%+9.6E*K\n", CCC(1), CCC(2), CCC(3), CCC(4) );
  printf("J2BB(J,H,K) = %9.6E%+9.6E*column(J)%+9.6E*column(H)%+9.6E*column(K)\n", CCC(1), CCC(2), CCC(3), CCC(4) );

  # save residuals
  fname = "psc2sdss.res";
  fid = fopen(fname,"w");
  fprintf(fid,"\tj\th\tk\tu\tg\tr\ti\tz\tcosmag\tsdssmag\tB\n");
  fprintf(fid,"%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n",
    transpose( [ j h k u g r i z cosmag sdssmag psc2mag(CCC,j,h,k)]) );
  fclose(fid);

  printf("%s saved\n", fname);

end


#######################################################################
# stage4 - non-linear spline approximation + extrapolation cosmag->sdss


function CCC = psc2sdss( color )
  switch ( color )
    case "SERCJ"
#      CCC = [+1.715296E+00 +4.293344E+00 -1.790370E+00 -1.578447E+00];
      CCC = [+2.313045E+00 +4.108905E+00 -1.713457E+00 -1.510638E+00];
    otherwise
      error("No calibration data for %s. Use stage3 to generate and insert it into this code.", color);
  end
end


global cosmagBreaks;  # cosmag spline breaks
global cosmagExtra;   # extrapolation pins

# mapping (cosmag,isky)->sdss
function smag = smap(S, PP, cosmag, isky)
  smag = ppval(PP,cosmag) + polyval(S, isky);
end

# regression function for leasqr()
function smag = lsfn(cosmag, p )
  global cosmagBreaks;
  global cosmagExtra;
  smag = pchip(cosmagBreaks, [ p; cosmagExtra], cosmag);
end

#
function [S, PP, SPX, SPY ] = smag_approximation( color, cosmag, isky, sdss )

  global cosmagBreaks;
  global cosmagExtra;

  switch ( color )
    case "SERCJ"
      cosmagBreaks = [-29.0; -27.0; -26.0; -25.5; -25.0; -24.5; -22.00; -21.00; -19.50];
      cosmagExtra =                                      [19.75;  20.70;  22.00];
  otherwise
    error("smag_approximation() is not implemented for %s", color);
  end

  p = zeros(size(cosmagBreaks,1)-size(cosmagExtra,1),1);
  [~, p,cvg,iter] = leasqr(cosmag, sdss, p, @lsfn, 1e-12, 200); # {stol,niter,wt,dp,dFdp,options}

  PP = pchip(cosmagBreaks, [p; cosmagExtra]);
  S = polyfit (isky, sdss - ppval(PP,cosmag), 3);

  printf("PP: cvg=%d,iter=%d\n", cvg, iter);
  disp(p);
  printf("S:\n");
  disp(S);

  SPX = cosmagBreaks;
  SPY = [p; cosmagExtra];

end


function calibrate_stage4( color, plateid, outname, noprep )

  # check if this plate is already processed
  if ( exist(outname,"file") )
    s = system(sprintf("egrep -q '^%d:' %s", plateid, outname));
    if ( s == 0 )
      printf("\nSKIP %d BECAUSE ALREADY PROCESSES\n\n", plateid);
      return;
    end
  end

  # get process id to format temporary file names
  pid = getpid();
  printf("pid=%d\n", pid);

  sname = sprintf("/tmp/scosmos.%d.%d.tmp", plateid, pid );
  spscname = sprintf("/tmp/scosmos.psc.%d.%d.tmp", plateid, pid);

  if ( noprep )
    pscname = "psc.dat";
  else
    pscname = sprintf("/tmp/psc.%d.%d.tmp", plateid, pid);
  end

  # get spsc
  status = mkspsc(plateid, sname, pscname, spscname, noprep, 0.1,0.1,0.1,5,16.5,4,20,4,20,-30,-23.9 );
  if ( !status )
    printf("\nSKIP %d BECAUSE mkspsc() FAILS\n\n", plateid);
    return;
  end


  # load reference stars
  printf("load reference stars\n");
  fid = popenq(spscname, "isky cosmag j_m h_m k_m" );
  if ( fid == -1 )
    error("ERROR: can not read %s\n", fname);
  end

  v = transpose(fscanf(fid, "%lf", [5, Inf]));
  pclose(fid);

  # remove temp files
  if ( noprep )
    syscall("rm -f %s %s", sname, spscname);
  else
    syscall("rm -f %s %s %s", sname, pscname, spscname);
  end

  # remove stars with poor sky background
  smin = min( v(:,1) ) + 1e6;
  smax = max( v(:,1) ) - 1e6;
  if ( ~all(good = v(:,1) >= smin & v(:,1) <= smax) )
    v = v (good,:);
  end

  # extract columns
  isky = v(:,1)*1e-7;
  cosmag = v(:,2);
  j = v(:,3);
  h = v(:,4);
  k = v(:,5);
  sdss = psc2mag( psc2sdss( color ), j, h, k );


  # reduce cosmag->sdss
  NPASS = 15;
  K = 3;
  for pass = 1:NPASS

    [S, PP, SPX, SPY] = smag_approximation( color, cosmag, isky, sdss );
    csdss = smap(S, PP, cosmag, isky);
    sigma = std(delta = sdss - csdss);

    printf("* %d: sigma=%g rows=%d\n", pass, sigma, rows(cosmag));

    if ( pass < NPASS )

      if ( all( good = abs(delta) < K * sigma ) )
        break;
      end

      cosmag = cosmag(good);
      isky = isky(good);
      sdss = sdss(good);
    end

  endfor


  iss = mean(isky) * ones(size(cosmag));
  dirname="mc.stage4.res";
  mkdir(dirname);
  fname = sprintf("%s/mc.%d.res", dirname, plateid);
  fid = fopen(fname,"w");
  fprintf(fid,"isky\tcosmag\tsdss\tcsdss\tpp\n");
  fprintf(fid,"%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n",
    transpose( [ isky cosmag sdss csdss smap(S,PP,cosmag,iss)] ) );
  fclose(fid);

  fname = sprintf("%s/mc.%d.sp", dirname, plateid);
  fid = fopen(fname,"w");
  fprintf(fid,"cosmag\tcsdss\n");
  xx = transpose([-300:-180]);
  isky = mean(isky) * ones(size(xx));
  cosmag = xx * 0.1;
  csdss = smap(S, PP, cosmag, isky);
  fprintf(fid,"%.3f\t%.3f\n",transpose( [ cosmag csdss ] ) );
  fclose(fid);

  # write final calibrations
  fname = outname;
  fid = fopen(fname,"a");
  if ( fid == -1 )
    error("Can not write %s\n", fname);
  end

  fprintf(fid,"%d:\n",plateid);
  fprintf(fid,"%+7.3f ",SPX);
  fprintf(fid,"\n");
  fprintf(fid,"%+7.3f ",SPY);
  fprintf(fid,"\n");
  fprintf(fid,"%+.12E ",transpose(S));
  fprintf(fid,"\n");
  fclose(fid);

end

#######################################################################
# stage5 - check it

function [S, PP] = loadspp( plateid, fname )
  if ( exist(fname,"file") )
    fid = popen(sprintf("egrep '^%d:' -A 3 %s", plateid, fname),"r");
    if ( ischar(fgets(fid)) && ischar(s1=fgets(fid)) && ischar(s2=fgets(fid)) && ischar(s3=fgets(fid)) )
      SPX = transpose(sscanf(s1,"%lf",[1,Inf]));
      SPY = transpose(sscanf(s2,"%lf",[1,Inf]));
      S   = sscanf(s3,"%lf",[1,Inf]);
      PP  = pchip(SPX, SPY);
    end
    pclose(fid);
  end
end



#######################################################################

stage = "";
plateid = [];
calibname = "";
color = "";
noprep = 0;
sdss2psc = {};
outname = "";

if ( nargin < 1 )
  show_usage( stderr );
  return;
end

stage = arg_list{1};
i = 1;
while ( ++i <= nargin )

  switch( stage )
   case "stage1"
      if ( strcmp(arg_list{i},"-o") )
        if ( i < nargin )
          calibname = arg_list{++i}
        else
          show_usage( stderr );return;
        endif
      elseif ( strcmp(arg_list{i},"-noprep") )
        noprep = 1
      else
        [x, ok] = str2num(arg_list{i});
        if ( !ok )
          fprintf(stderr,"Syntax error in argument: %s\n", arg_list{i});
          show_usage( stderr );return;
        end
        plateid = [ plateid x ];
      endif

   case "stage2"
    if ( strcmp( calibname, "" ) )
      calibname = arg_list{i}
    else
      fprintf(stderr,"Syntax error in argument: %s\n", arg_list{i});
      show_usage( stderr );return;
    endif

   case "stage3"
      if ( strcmp(arg_list{i},"-c") )
        if ( i < nargin )
          color = arg_list{++i}
        else
          show_usage( stderr );return;
        endif
      else
        sdss2psc{size(sdss2psc,2)+1} = arg_list{i};
      endif

   case "stage4"
      if ( strcmp(arg_list{i},"-c") )
        if ( i < nargin )
          color = arg_list{++i}
        else
          show_usage( stderr );return;
        endif
      elseif ( strcmp(arg_list{i},"-o") )
        if ( i < nargin )
          outname = arg_list{++i}
        else
          show_usage( stderr );return;
        endif
      elseif ( strcmp(arg_list{i},"-noprep") )
        noprep = 1
      else
        [x, ok] = str2num(arg_list{i});
        if ( !ok )
          fprintf(stderr,"Syntax error in argument: %s\n", arg_list{i});
          show_usage( stderr );return;
        end
        plateid = [ plateid x ];
      endif

   case "stage5"
      if ( strcmp(arg_list{i},"-c") )
        if ( i < nargin )
          color = arg_list{++i}
        else
          show_usage( stderr );return;
        endif
      elseif ( strcmp(arg_list{i},"-calib") )
        if ( i < nargin )
          calibname = arg_list{++i}
        else
          show_usage( stderr );return;
        endif
      else
        [x, ok] = str2num(arg_list{i});
        if ( !ok )
          fprintf(stderr,"Syntax error in argument: %s\n", arg_list{i});
          show_usage( stderr );return;
        end
        plateid = [ plateid x ];
      endif


  endswitch
end


switch( stage )

 case "stage1"
    if ( size(plateid,2) < 1 || strcmp(calibname,"") )
      show_usage( stderr );
      return;
    end

    pkg load optim;

    for i = 1:size(plateid,2)
      pid = plateid(i);
      printf("\nPLATE %d\n", pid);
      calibrate_stage1( pid, calibname, noprep );
    end


 case "stage2"
    if ( strcmp(calibname,"") )
      show_usage( stderr );
      return;
    end

    calibrate_stage2(calibname);


 case "stage3"
    if ( strcmp(color,"") || size(sdss2psc,2) < 1 )
      show_usage( stderr );
      return;
    end

    pkg load optim;
    calibrate_stage3( color, sdss2psc );

 case "stage4"
    if ( size(plateid,2) < 1 || strcmp(color,"") || strcmp(outname,"") )
      show_usage( stderr );
      return;
    end

    pkg load optim;

    for i = 1:size(plateid,2)
      pid = plateid(i);
      printf("\nPLATE %d\n", pid);
      calibrate_stage4( color, pid, outname, noprep );
    end

 case "stage5"
    if ( size(plateid,2) < 1 || strcmp(calibname,"") )
      show_usage( stderr );
      return;
    end

    for i = 1:size(plateid,2)
      pid = plateid(i);
      printf("\nPLATE %d\n", pid);
      loadspp( plateid, calibname );
    end

 otherwise
  show_usage( stderr );
  return;
endswitch



#######################################################################
